/*
	Game description framework 
	author: Anonym
	contributor: Anonym 2
	SWI-Prolog version
	Last update: 06/08/2024
*/

/* Game independent description */

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F).  
game(S,F):- \+ final(S), legal(M,S), game(do(M,S),F).

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).

/* Game specific predicates for PD-like games */

% Initial state
initial(s0).

% What holds initially: who is a player, their role, and whether they can play.	
initially(player(you), s0).
initially(player(them), s0).
initially(role(you,row), s0).
initially(role(them,col), s0).
initially(control(you), s0).
initially(control(them), s0).

% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(choice(_P2, _M2), do(choice(_P1, _M1), S))):-initial(S).

% A legal move is a possible move where the player has control (is its turn).
legal(choice(P, M), S):- possible(choice(P, M), S), holds(control(P), S).

% What is possible for a player to choose
possible(choice(P,'B'), S):- holds(player(P), S).
possible(choice(P,'R'), S):- holds(player(P), S).

% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), choice(P, M), _S).

% The effects of a move: once a choice is made, the player looses control, i.e.
% cannot move anymore.
abnormal(control(P), choice(P, _M), _S).

% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(P1,M1,U1,P2,M2,U2), S):-
	final(S),
	holds(role(P1, row), S),	
	holds(did(P1, M1), S),	
	holds(role(P2, col), S),	
	holds(did(P2, M2), S),
	payoff(M1, M2, U1, U2).

% Goals achieved by the players.
finally(goal(P1, U1), S):-
	finally(outcome(P1,_,U1,_,_,_), S).
finally(goal(P2, U2), S):-
	finally(outcome(_,_,_,P2,_,U2), S).

/* Auxiliary predicates */

minU(M, U):-
	findall(X, payoff(M, _, X, _), Xs),
	sort(Xs, [U|_]).
	
higher_guaranteed_payoff(M1, M2):-
	minU(M1, U1),
	minU(M2, U2),
	U1 > U2.
	
lower_guaranteed_payoff(M1, M2):-
	minU(M1, U1),
	minU(M2, U2),
	U1 < U2.

higher(X, Y) :-
    X > Y.
    
lower(X, Y) :-
    X < Y.
    
lowest_payoff(Payoff) :-
    findall(P, (payoff(_, _, P, _); payoff(_, _, _, P)), Payoffs),
    min_list(Payoffs, MinPayoff),
    Payoff = MinPayoff.
    
highest_payoff(Payoff) :-
    findall(P, (payoff(_, _, P, _); payoff(_, _, _, P)), Payoffs),
    max_list(Payoffs, MaxPayoff),
    Payoff = MaxPayoff.
    
lowest_individual_payoff_for_choice(Payoff, Choice) :-
    payoff(Choice, _, Payoff, _),
    \+ (payoff(Choice, _, P1, _), P1 < Payoff).
    
highest_individual_payoff_for_choice(Payoff, Choice) :-
    payoff(Choice, _, Payoff, _),
    \+ (payoff(Choice, _, P1, _), P1 > Payoff).  
    
highest_guaranteed_payoff_choice(Choice) :-
    findall(Payoff, lowest_individual_payoff_for_choice(Payoff, _), Payoffs),
    max_list(Payoffs, LowestPayoff),
    lowest_individual_payoff_for_choice(LowestPayoff, Choice).
    
lowest_guaranteed_payoff_choice(Choice) :-
    findall(LowestPayoff, lowest_individual_payoff_for_choice(LowestPayoff, _), LowestPayoffs),
    min_list(LowestPayoffs, MaxLowestPayoff),
    lowest_individual_payoff_for_choice(MaxLowestPayoff, Choice).    
    
highest_possible_individual_payoff(Payoff) :-
    findall(P, (payoff(_, _, P, _); payoff(_, _, _, P)), Payoffs),
    max_list(Payoffs, MaxPayoff),
    Payoff = MaxPayoff.
    
lowest_possible_individual_payoff(Payoff) :-
    findall(P, (payoff(_, _, P, _); payoff(_, _, _, P)), Payoffs),
    min_list(Payoffs, MaxPayoff),
    Payoff = MaxPayoff. 
    
highest_mutual_payoff(Choice1, Choice2) :-
    findall(Total, (
        payoff(_, _, Payoff1, Payoff2),
        Total is Payoff1 + Payoff2,
        Payoff1 =:= Payoff2
    ), Totals),
    max_list(Totals, MaxTotal),
    payoff(Choice1, Choice2, Payoff1, Payoff2),
    Payoff1 + Payoff2 =:= MaxTotal.
    
lowest_mutual_payoff(Choice1, Choice2) :-
    findall(Total, (
        payoff(_, _, Payoff1, Payoff2),
        Total is Payoff1 + Payoff2,
        Payoff1 =:= Payoff2
    ), Totals),
    min_list(Totals, MaxTotal),
    payoff(Choice1, Choice2, Payoff1, Payoff2),
    Payoff1 + Payoff2 =:= MaxTotal.
